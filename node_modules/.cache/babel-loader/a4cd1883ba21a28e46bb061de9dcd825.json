{"ast":null,"code":"export function fixTail(num, n = 5) {\n  const biasedNumStr = (num + 10 ** (-n - 1)).toFixed(n);\n  return Number(biasedNumStr);\n}\n\nfunction gaussJordan(matrix) {\n  let ratio;\n  const matrixCopy = matrix.map(row => row.map(el => el));\n\n  for (let i = 0; i < matrixCopy.length; i++) {\n    for (let j = 0; j < matrixCopy.length; j++) {\n      if (i !== j) {\n        ratio = matrixCopy[j][i] / matrixCopy[i][i];\n\n        for (let k = 0; k <= matrixCopy.length; k++) {\n          matrixCopy[j][k] = matrixCopy[j][k] - ratio * matrixCopy[i][k];\n        }\n      }\n    }\n  }\n\n  let UNS_Object = [];\n\n  for (let i = 0; i < matrixCopy.length; i++) {\n    UNS_Object.push(fixTail(matrixCopy[i][matrixCopy.length] / matrixCopy[i][i]));\n  }\n\n  return UNS_Object;\n}\n\nfunction calculate(rodsRows, nodesRows, leftSupport, rightSupport) {\n  const rodsData = rodsRows;\n  const nodesData = nodesRows;\n  const left = leftSupport.isChecked;\n  const right = rightSupport.isChecked;\n  const rods = rodsData.map(rod => [rod.modulus, rod.area, rod.length]);\n  const nodesLoads = nodesData.map(node => node.nodeForce);\n  const rodsLoads = rodsData.map(rod => rod.distLoad);\n  const matrixA = [];\n\n  for (let i = 0; i < rods.length + 1; i++) {\n    const matrixRow = [];\n\n    for (let j = 0; j < rods.length + 1; j++) {\n      matrixRow.push(0);\n    }\n\n    matrixA.push(matrixRow);\n  }\n\n  const rodSquares = [];\n  rods.forEach(rod => {\n    let currentSquare = [];\n\n    for (let i = 0; i < 2; i++) {\n      currentSquare.push([0, 0]);\n    }\n\n    currentSquare = currentSquare.map(value => value.map(() => rod[0] * rod[1] / rod[2]));\n    currentSquare[0][1] *= -1;\n    currentSquare[1][0] *= -1;\n    rodSquares.push(currentSquare);\n  });\n  rodSquares.forEach((square, index) => {\n    for (let i = index; i < index + 2; i++) {\n      for (let k = index; k < index + 2; k++) {\n        if (i === k) {\n          if (i === 0 || i === matrixA.length - 1) {\n            matrixA[i][k] = square[i - index][k - index];\n          } else {\n            matrixA[i][k] += square[i - index][k - index];\n          }\n        } else {\n          matrixA[i][k] = square[i - index][k - index];\n        }\n      }\n    }\n  });\n\n  if (left) {\n    for (let i = 0; i < matrixA.length; i++) {\n      for (let k = 0; k < matrixA.length; k++) {\n        if (i !== k && (i === 0 || k === 0)) {\n          matrixA[i][k] = 0;\n        }\n\n        if (i === k && i === 0) {\n          matrixA[i][k] = 1;\n        }\n      }\n    }\n  }\n\n  if (right) {\n    for (let i = 0; i < matrixA.length; i++) {\n      for (let k = 0; k < matrixA.length; k++) {\n        if (i !== k && (i === matrixA.length - 1 || k === matrixA.length - 1)) {\n          matrixA[i][k] = 0;\n        }\n\n        if (i === k && i === matrixA.length) {\n          matrixA[i][k] = 1;\n        }\n      }\n    }\n  }\n\n  const matrixB = [];\n\n  for (let i = 0; i < matrixA.length; i++) {\n    if (left && i === 0 || right && i === matrixA.length - 1) {\n      matrixB.push(0);\n    } else if (i !== 0 && i !== matrixA.length - 1) {\n      matrixB.push(nodesLoads[i] + rodsLoads[i] * (rods[i][2] / 2) + rodsLoads[i - 1] * (rods[i - 1][2] / 2));\n    } else if (i === 0) {\n      matrixB.push(nodesLoads[i] + rodsLoads[i] * (rods[i][2] / 2));\n    } else if (i === matrixA.length - 1) {\n      matrixB.push(nodesLoads[i] + rodsLoads[i - 1] * (rods[i - 1][2] / 2));\n    }\n  }\n\n  const SLAU = matrixA.map((row, index) => {\n    return [...row, matrixB[index]];\n  });\n  const deltaMatrix = gaussJordan(SLAU);\n  const alertData = deltaMatrix.map((result, index) => {\n    return `\\nDelta ${index + 1} = ${result}`;\n  });\n  alert(`Результаты вычислений: ${alertData}`);\n  const U = [];\n  rods.forEach((rod, index) => {\n    const Ux = x => Number((deltaMatrix[index] + x / rod[2] * (deltaMatrix[index + 1] - deltaMatrix[index]) + rodsLoads[index] * rod[2] * rod[2] / (2 * rod[0] * rod[1]) * (x / rod[2]) * (1 - x / rod[2])).toFixed(12));\n\n    U.push(Ux);\n  });\n  const N = [];\n  const S = [];\n  rods.forEach((rod, index) => {\n    const Nx = x => Number((rod[0] * rod[1] / rod[2] * (deltaMatrix[index + 1] - deltaMatrix[index]) + rodsLoads[index] * rod[2] / 2 * (1 - 2 * (x / rod[2]))).toFixed(10));\n\n    N.push(Nx);\n    S.push(x => Nx(x) / rod[1]);\n  });\n  const UNS_Object = {\n    U: U,\n    N: N,\n    S: S\n  };\n  return UNS_Object;\n}\n\nexport default calculate;","map":{"version":3,"sources":["C:/Users/glush/Desktop/react-sapr-main/src/components/Processor/calculate.js"],"names":["fixTail","num","n","biasedNumStr","toFixed","Number","gaussJordan","matrix","ratio","matrixCopy","map","row","el","i","length","j","k","UNS_Object","push","calculate","rodsRows","nodesRows","leftSupport","rightSupport","rodsData","nodesData","left","isChecked","right","rods","rod","modulus","area","nodesLoads","node","nodeForce","rodsLoads","distLoad","matrixA","matrixRow","rodSquares","forEach","currentSquare","value","square","index","matrixB","SLAU","deltaMatrix","alertData","result","alert","U","Ux","x","N","S","Nx"],"mappings":"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","sourcesContent":["export function fixTail(num, n = 5) {\n    const biasedNumStr = (num + 10 ** (-n - 1)).toFixed(n);\n    return Number(biasedNumStr);\n}\n\nfunction gaussJordan(matrix) {\n    let ratio;\n    const matrixCopy = matrix.map((row) => row.map((el) => el));\n    for (let i = 0; i < matrixCopy.length; i++) {\n        for (let j = 0; j < matrixCopy.length; j++) {\n            if (i !== j) {\n                ratio = matrixCopy[j][i] / matrixCopy[i][i];\n                for (let k = 0; k <= matrixCopy.length; k++) {\n                    matrixCopy[j][k] =\n                        matrixCopy[j][k] - ratio * matrixCopy[i][k];\n                }\n            }\n        }\n    }\n    let UNS_Object = [];\n    for (let i = 0; i < matrixCopy.length; i++) {\n        UNS_Object.push(\n            fixTail(matrixCopy[i][matrixCopy.length] / matrixCopy[i][i])\n        );\n    }\n    return UNS_Object;\n}\n\nfunction calculate(rodsRows, nodesRows, leftSupport, rightSupport) {\n    const rodsData = rodsRows;\n    const nodesData = nodesRows;\n    const left = leftSupport.isChecked;\n    const right = rightSupport.isChecked;\n\n    const rods = rodsData.map((rod) => [rod.modulus, rod.area, rod.length]);\n    const nodesLoads = nodesData.map((node) => node.nodeForce);\n\n    const rodsLoads = rodsData.map((rod) => rod.distLoad);\n\n    const matrixA = [];\n    for (let i = 0; i < rods.length + 1; i++) {\n        const matrixRow = [];\n        for (let j = 0; j < rods.length + 1; j++) {\n            matrixRow.push(0);\n        }\n        matrixA.push(matrixRow);\n    }\n\n    const rodSquares = [];\n\n    rods.forEach((rod) => {\n        let currentSquare = [];\n        for (let i = 0; i < 2; i++) {\n            currentSquare.push([0, 0]);\n        }\n        currentSquare = currentSquare.map((value) =>\n            value.map(() => (rod[0] * rod[1]) / rod[2])\n        );\n        currentSquare[0][1] *= -1;\n        currentSquare[1][0] *= -1;\n        rodSquares.push(currentSquare);\n    });\n\n\n    rodSquares.forEach((square, index) => {\n        for (let i = index; i < index + 2; i++) {\n            for (let k = index; k < index + 2; k++) {\n                if (i === k) {\n                    if (i === 0 || i === matrixA.length - 1) {\n                        matrixA[i][k] = square[i - index][k - index];\n                    } else {\n                        matrixA[i][k] += square[i - index][k - index];\n                    }\n                } else {\n                    matrixA[i][k] = square[i - index][k - index];\n                }\n            }\n        }\n    });\n\n    if (left) {\n        for (let i = 0; i < matrixA.length; i++) {\n            for (let k = 0; k < matrixA.length; k++) {\n                if (i !== k && (i === 0 || k === 0)) {\n                    matrixA[i][k] = 0;\n                }\n                if (i === k && i === 0) {\n                    matrixA[i][k] = 1;\n                }\n            }\n        }\n    }\n    if (right) {\n        for (let i = 0; i < matrixA.length; i++) {\n            for (let k = 0; k < matrixA.length; k++) {\n                if (\n                    i !== k &&\n                    (i === matrixA.length - 1 || k === matrixA.length - 1)\n                ) {\n                    matrixA[i][k] = 0;\n                }\n                if (i === k && i === matrixA.length) {\n                    matrixA[i][k] = 1;\n                }\n            }\n        }\n    }\n\n    const matrixB = [];\n    for (let i = 0; i < matrixA.length; i++) {\n        if ((left && i === 0) || (right && i === matrixA.length - 1)) {\n            matrixB.push(0);\n        } else if (i !== 0 && i !== matrixA.length - 1) {\n            matrixB.push(\n                nodesLoads[i] +\n                    rodsLoads[i] * (rods[i][2] / 2) +\n                    rodsLoads[i - 1] * (rods[i - 1][2] / 2)\n            );\n        } else if (i === 0) {\n            matrixB.push(nodesLoads[i] + rodsLoads[i] * (rods[i][2] / 2));\n        } else if (i === matrixA.length - 1) {\n            matrixB.push(\n                nodesLoads[i] + rodsLoads[i - 1] * (rods[i - 1][2] / 2)\n            );\n        }\n    }\n    const SLAU = matrixA.map((row, index) => {\n        return [...row, matrixB[index]];\n    });\n    const deltaMatrix = gaussJordan(SLAU);\n    const alertData = deltaMatrix.map((result, index) => {\n        return `\\nDelta ${index+1} = ${result}`\n    })\n\n    alert(`Результаты вычислений: ${alertData}`);\n\n    const U = [];\n    rods.forEach((rod, index) => {\n        const Ux = (x) =>\n            Number(\n                (\n                    deltaMatrix[index] +\n                    (x / rod[2]) *\n                        (deltaMatrix[index + 1] - deltaMatrix[index]) +\n                    ((rodsLoads[index] * rod[2] * rod[2]) /\n                        (2 * rod[0] * rod[1])) *\n                        (x / rod[2]) *\n                        (1 - x / rod[2])\n                ).toFixed(12)\n            );\n        U.push(Ux);\n    });\n\n    const N = [];\n    const S = [];\n    rods.forEach((rod, index) => {\n        const Nx = (x) =>\n            Number(\n                (\n                    ((rod[0] * rod[1]) / rod[2]) *\n                        (deltaMatrix[index + 1] - deltaMatrix[index]) +\n                    ((rodsLoads[index] * rod[2]) / 2) * (1 - 2 * (x / rod[2]))\n                ).toFixed(10)\n            );\n        N.push(Nx);\n        S.push((x) => Nx(x) / rod[1]);\n    });\n\n    const UNS_Object = {\n        U: U,\n        N: N,\n        S: S,\n    };\n    return UNS_Object;\n}\n\nexport default calculate;\n"]},"metadata":{},"sourceType":"module"}